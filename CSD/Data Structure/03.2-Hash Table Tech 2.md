# ğŸ§  Perfect Hashing & Cuckoo Hashing

---

## âœ¨ Lecture Overview

In this lecture, we study **two advanced hashing techniques** that aim to overcome the limitations of traditional hashing:

* ğŸŸ¢ **Perfect Hashing** â€” guarantees **no collisions** (given all keys upfront)
* ğŸ¦ **Cuckoo Hashing** â€” guarantees **Î˜(1) worst-case lookup time**

These techniques go beyond chaining and open addressing, using probability, randomness, and clever structure to achieve strong guarantees.

---

## â“ Why Is Hashing Not Perfect?

Traditional hash tables suffer from **collisions**:

* Multiple keys map to the same slot
* Must resolve using:

  * Chaining
  * Open addressing

âš ï¸ **Worst-case problem**:
If an adversary knows your hash function, they can force many collisions, degrading performance.

---

## ğŸ² Universal Hash Functions (Quick Recap)

A **universal hash family** is a *set of hash functions* with this property:

> For any two distinct keys `káµ¢ â‰  kâ±¼`, the probability they collide (over random choice of hash function) is â‰¤ **c / m**

Where:

* `m` = number of hash table slots
* `c` = small constant (often 1)

ğŸ’¡ Randomness comes from **choosing the hash function**, not from the keys.

---

## ğŸ“Š Expected Behavior with Chaining

If:

* `n` = number of keys
* `m` = number of slots
* `Î± = n / m` = load factor

Then:

* Average chain length â‰ˆ `Î± + 1`
* Longest chain (with high probability):

```math
Î˜(log n / log log n)
```

ğŸ‘ Good in practice, but:

* âŒ Still not a constant worst case

---

## ğŸ¯ What Does â€œPerfectâ€ Mean?

Perfect hashing means:

âœ… **No collisions at all**
âœ… **Î˜(1) lookup guaranteed**

We will see **two approaches**:

1. Perfect Hashing (static keys)
2. Cuckoo Hashing (dynamic keys)

---

#  ğŸŸ¢ Perfect Hashing

## ğŸ§© Problem Setting

Given:

* `n` **distinct keys** `kâ‚, kâ‚‚, â€¦, kâ‚™`
* All keys are **known upfront**

Goal:

> Build a hash table where **no two keys collide**

âš ï¸ No insertions or deletions after construction.

---

## ğŸ§ª Naive Perfect Hashing Idea

### Step 1: Huge Hash Table

* Use `m = K Â· nÂ²` slots
* Choose a random hash function from a universal family

### Step 2: Insert All Keys

* If **any collision occurs** â†’ abort and retry with a new hash function

---

## ğŸ“ Why This Works (Probability Intuition)

* Probability two keys collide: `â‰¤ c / (K Â· nÂ²)`
* Number of key pairs: `n(nâˆ’1)/2`

Using **Booleâ€™s inequality**:

```
P(any collision) â‰¤ c / (2K)
```

Choose `K = 2c` â†’ collision probability â‰¤ 1/4

ğŸ² Expected retries â‰ˆ **4/3** (geometric trial)

âœ… Infinite loop is astronomically unlikely

---

## ğŸš¨ Problem: Space Explosion

Example:

* `n = 1,000,000`
* `m = 2nÂ² = 2 Ã— 10Â¹Â²` slots âŒ

â¡ï¸ Totally impractical

---

## ğŸ§  Solution: Two-Level Perfect Hashing

### ğŸ”¹ Level 1: Primary Hash Table

* Size: `n`
* Hash function: `hâ‚`
* Keys distribute into slots

### ğŸ”¹ Level 2: Secondary Hash Tables

For slot `j`:

* Let `nâ±¼` = number of keys hashing to slot `j`
* Create a **secondary table** of size `nâ±¼Â²`
* Choose a new random hash function `hâ±¼`

ğŸ“Œ This replaces **chaining** with **perfect hashing per slot**

---

![Perfect Hashing](hash_table_9.gif)

---

## ğŸ“Š Space Complexity Result

Let:

```math
Total space = Î£ nâ±¼Â²
```

âœ¨ Key result:

```math
E[Î£ nâ±¼Â²] = O(n)
```

So total space:

* Primary table: `O(n)`
* Secondary tables (expected): `O(n)`

ğŸ‰ Perfect hashing with **linear space**!

---

## âœ… Properties of Perfect Hashing

âœ” No collisions
âœ” Î˜(1) worst-case lookup
âœ” Linear space (expected)

âŒ Keys must be known upfront
âŒ No insert / delete support

---

# ğŸ¦ Cuckoo Hashing

## ğŸ’¡ Motivation

Lift limitations of perfect hashing:

* Support **insertions & deletions**
* Still guarantee **Î˜(1) lookup time**

---

## ğŸ§  Core Idea

Use:

* **Two hash tables**
* **Two hash functions** `hâ‚`, `hâ‚‚`

Each key `k` can be stored in:

```cpp
Table1[hâ‚(k)]  OR  Table2[hâ‚‚(k)]
```

---

## ğŸ” Lookup Operation

```cpp
Check Table1[hâ‚(k)]
If not found â†’ check Table2[hâ‚‚(k)]
```

âœ… Always **2 probes** â†’ Î˜(1) worst-case

---

## â• Insertion (The â€œCuckooâ€ Step)

1. Try `Table1[hâ‚(k)]`
2. If occupied â†’ kick out existing key
3. Insert displaced key into its *other* table
4. Continue displacement chain

ğŸ¦ Like a cuckoo bird pushing eggs out of nests

---

![Cuckoo Hashing](hash_table_10.gif)

---

## ğŸ” Displacement Chains

Possible outcomes:

* âœ… Chain finds empty slot â†’ success
* âš ï¸ Chain becomes too long
* âŒ Cycle detected

â¡ï¸ If too many displacements:

ğŸ”„ **Rehash entire table** with new hash functions

---

## â±ï¸ Complexity Summary

| Operation | Complexity      |
| --------- | --------------- |
| Lookup    | Î˜(1) worst-case |
| Delete    | Î˜(1)            |
| Insert    | Î˜(1) expected   |
| Rehash    | Rare, amortized |

ğŸ“Œ Analysis is complex but guarantees are strong

---

## ğŸ†š Perfect Hashing vs Cuckoo Hashing

| Feature            | Perfect Hashing | Cuckoo Hashing     |
| ------------------ | --------------- | ------------------ |
| Collisions         | None            | None during lookup |
| Lookup             | Î˜(1)            | Î˜(1)               |
| Insert/Delete      | âŒ               | âœ”                  |
| Keys known upfront | âœ”               | âŒ                  |
| Complexity         | Easier          | Harder             |

---

## ğŸ§  Final Takeaways

* **Perfect Hashing** achieves absolute collision freedom for static data
* **Cuckoo Hashing** enables dynamic hashing with guaranteed fast lookup
* Both rely on:

  * Randomized hash functions
  * Clever probabilistic guarantees

ğŸš€ These are among the most elegant ideas in hashing theory