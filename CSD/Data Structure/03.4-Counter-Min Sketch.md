# ðŸ“Š Count-Min Sketch (CMS)

## ðŸŽ¯ What is a Count-Min Sketch?

A **Count-Min Sketch** is a **probabilistic data structure** that uses **hashing** to maintain **approximate frequency counts** of elements in a large data stream.

It is especially useful when:

* The stream is **huge** (millions or billions of items)
* The number of **distinct elements is unknown**
* Exact counting is **too expensive** in memory

Instead of storing exact counters for every distinct element, CMS trades **accuracy for efficiency**, while providing strong probabilistic guarantees.

---

## ðŸŒŠ Problem Setup: Counting in Data Streams

We are given a data stream:

```math
xâ‚, xâ‚‚, xâ‚ƒ, â€¦, x_W
```

Where:

* **W** = total number of elements in the stream (can be very large)
* Each element may repeat
* The number of **distinct items (N)** is unknown

### â“ Query Goal

We want to answer queries like:

> "How many times did element `x` appear in the stream?"

But:

* Exact counts are not required
* An **approximate count** is acceptable

---

## ðŸŽ¯ Accuracy Guarantee

A Count-Min Sketch guarantees:

```math
ApproxCount(x) â‰¤ TrueCount(x) + Îµ Â· W
```

With probability at least:

```math
1 âˆ’ Î´
```

Where:

* **Îµ (epsilon)** = error fraction
* **Î´ (delta)** = failure probability

### ðŸ“Œ Example

* W = 1,000,000,000 (1 billion)
* Îµ = 10â»â¶ â†’ allowable error = 1,000
* Î´ = 0.01 â†’ 99% confidence

âž¡ï¸ The reported count is within **Â±1000** of the true count, **99% of the time**.

---

## ðŸ§  Core Idea

Count-Min Sketch uses:

* Multiple **hash functions**
* Multiple **arrays of counters** (called *counter banks*)

Each incoming element updates **one counter per bank**.

---

## ðŸ§± Data Structure Layout

* **k** counter banks
* Each bank has **m counters**
* Each bank has its **own independent hash function**

```cpp
Bank 1: [ câ‚â‚ câ‚â‚‚ câ‚â‚ƒ ... câ‚m ]  â† hâ‚(x)
Bank 2: [ câ‚‚â‚ câ‚‚â‚‚ câ‚‚â‚ƒ ... câ‚‚m ]  â† hâ‚‚(x)
...
Bank k: [ ckâ‚ ckâ‚‚ ckâ‚ƒ ... ckm ]  â† h_k(x)
```

---

## âž• Insert Operation

For each incoming stream element `x`:

```cpp
for i = 1 to k:
    index = háµ¢(x)
    counter_bank[i][index] += 1
```

â±ï¸ Time complexity: **O(k)**

---

![Insert Operation](counter-min_sketch_1.png)

---

## ðŸ” Query Operation

To estimate the count of element `x`:

```cpp
return min(
    counter_bank[1][hâ‚(x)],
    counter_bank[2][hâ‚‚(x)],
    ...,
    counter_bank[k][h_k(x)]
)
```

### ðŸ¤” Why take the minimum?

Each counter may **overestimate** due to hash collisions.

Taking the **minimum** gives:

* The **least overestimated** value
* Best approximation of the true count

> ðŸ’¡ Analogy: Asking multiple vendors for a price â€” all overcharge, so you pick the lowest one.

---

![Counter-min sketch 2](counter-min_sketch_2.png)

---

## âš ï¸ Why Counts Are Approximate

Because:

* Multiple elements can hash to the **same counter**
* Counters accumulate **extra increments**

âž¡ï¸ Errors are always **positive** (overestimation only)

âŒ No underestimation

---

![Counter-min skektch 3](counter-min_sketch_3.png)

---

## ðŸ“ Error Analysis (High Level)

### Expected Error (Single Bank)

```math
E[error] â‰¤ (C / m) Â· W
```

Where:

* C â‰ˆ 1 (from universal hashing)
* m = number of counters per bank

### Choosing m

To bound error â‰¤ ÎµÂ·W:

```math
m â‰ˆ e Â· C / Îµ
```

This guarantees:

```math
P(error â‰¥ ÎµÂ·W) â‰¤ 1/e
```

---

## ðŸ” Reducing Error with Multiple Banks

We use **k independent banks**.

* Each bank fails with probability â‰¤ 1/e
* All k banks fail with probability:

```math
(1/e)áµ
```

To achieve confidence â‰¥ 1 âˆ’ Î´:

```math
k â‰¥ ln(1 / Î´)
```

âž¡ï¸ Error probability decreases **exponentially** with k

---

## ðŸ§® Parameter Summary

| Parameter | Meaning                               |
| --------- | ------------------------------------- |
| m         | Counters per bank (controls accuracy) |
| k         | Number of banks (controls confidence) |
| Îµ         | Error tolerance                       |
| Î´         | Failure probability                   |

---

## ðŸ§ª Typical Configuration Example

* W = 10â¹
* Îµ = 10â»â¶ (error â‰¤ 1000)
* Î´ = 0.1 (90% confidence)

Choose:

* m â‰ˆ 3,000,000
* k â‰ˆ 3

Total counters â‰ˆ 9 million

âž¡ï¸ Massive memory savings compared to exact counting

---

## âœ… Strengths of Count-Min Sketch

âœ” Extremely memory efficient
âœ” Fast updates and queries
âœ” Works on streaming data
âœ” Simple to implement
âœ” Strong probabilistic guarantees

---

## âŒ Limitations

âœ˜ Counts are approximate
âœ˜ Overestimation only
âœ˜ Cannot list all items
âœ˜ Requires careful parameter tuning

---

## ðŸ“¦ Common Applications

* Web request frequency counting
* Heavy hitter detection
* Network traffic analysis
* Query frequency estimation
* Log analytics
* Streaming analytics systems

---

## ðŸ”— Related Data Structures

* Bloom Filter (membership only)
* Counting Bloom Filter
* Cuckoo Filter
* Heavy Hitters (Misraâ€“Gries)

---

## ðŸ§  Key Takeaway

> **Count-Min Sketch provides fast, space-efficient approximate frequency counting with guaranteed error bounds â€” ideal for massive data streams.**
